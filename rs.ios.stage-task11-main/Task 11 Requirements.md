### Введение

Итак, 11 таск.

Задача достаточно простая. Нужно написать клиент для небольшой части неофициального API SpaceX:

[https://github.com/r-spacex/SpaceX-API](https://github.com/r-spacex/SpaceX-API)

Для нас будут интересны следующие эндпоинты:

- [https://github.com/r-spacex/SpaceX-API/tree/master/docs/rockets/v4](https://github.com/r-spacex/SpaceX-API/tree/master/docs/rockets/v4)
- [https://github.com/r-spacex/SpaceX-API/tree/master/docs/launches/v5](https://github.com/r-spacex/SpaceX-API/tree/master/docs/launches/v5)
- [https://github.com/r-spacex/SpaceX-API/tree/master/docs/launchpads/v4](https://github.com/r-spacex/SpaceX-API/tree/master/docs/launchpads/v4)

По ссылкам описаны сами URL для запросов и приходящие с них данные в формате JSON. Вам необходимо их распарсить в объекты, с которыми вы будете работать в приложении.  

Сам дизайн приложения находится, как и всегда, в figma:

- [https://www.figma.com/file/XBWkCkppfG8liSBVsnd9Kq/Task-11?node-id=0%3A1](https://www.figma.com/file/XBWkCkppfG8liSBVsnd9Kq/Task-11?node-id=0%3A1)

Экранов немного, но на каждом достаточно большое количество различных мелких элементов интерфейса, каждый из которых - со своим приколом.

### Цели задания

Совсем недавно были лекции по многопоточности, работе с сетью, анимациям и юнит-тестам. В работе над заданием вам будет необходимо применить все эти знания (или получить их). 

Типы, работающие с сетью и преобразующие данные, должны быть покрыты юнит-тестами. При их написании старайтесь опираться на принципы FIRST. Также стремитесь к тому, чтобы покрытие тестами достигало 80% (+-40%, потому что по результатам прошлого года это было трудно получить). 

Подумайте над тем, как бы кешировать данные (изображения, ответы с сервера), чтобы сократить количество отправляемых в сеть запросов. Это, кстати, тоже можно будет покрыть юнит-тестами.

В UI большое внимание уделите кастомным переходам между контроллерами. В Figma схематично продемонстрированы базовые пункты, которые нужно учитывать при их создании. Если у вас есть идеи как сделать эти переходы более элегантными, тогда смело реализуйте их в своём проекте. 

Переходы в тех местах, где сохраняется `navigationbar`, должны быть интерактивными. 

Для реализации отметки на карте необходимо использовать фреймворк `MapKit`, а для открытия ссылок - `WebKit`. 

Нужно учитывать, что отображение элементов UI зависит от приходящих в JSON данных. Если какая-то часть в этом JSON отсутствует, тогда и элемент на интерфейсе отсутствует. Если, например, приходит пустой массив ссылок на изображения, тогда раздел с изображениями не отображается. По такой же логике работают и остальные данные. 

Обратите внимание, что при переходе из списков `tabbar` прячется. 

Элемент с картой не должен быть интерактивным. 

Для элемента `webview` ****правила следующие:

- состояние кнопок "forward" и "backward" должно отражать возможность перехода между страницами: например, если до этого не было открытых ссылок, тогда кнопка "назад" неактивна
- кнопка "share" должна открывать системный диалог (`UIActivityViewController`), через который пользователь может поделиться текущей открытой ссылкой
- кнопка "safari" должна открывать текущую ссылку в браузере Safari
- кнопка "reload" должна перезагружать текущую открытую страницу; во время перезагрузки эта кнопка должна быть неактивна, во все остальные - активна

Нажатие кнопок должно быть анимировано (придумайте сами).

### Требования

- iOS 12.1+
- Использование сторонних (не из стандартного SDK) библиотек запрещено
- Использование Storyboard запрещено
- Язык программирования Swift
- Для реализации интерфейса используется UIKit

## Чек-лист для оценки

- Вёрстка норм между устройствами
- Присутствуют кастомные переходы
- Есть адекватные unit-тесты, которые покрывают бизнес-логику приложения
- Нет утечек памяти

Возможно пополнение этого списка...